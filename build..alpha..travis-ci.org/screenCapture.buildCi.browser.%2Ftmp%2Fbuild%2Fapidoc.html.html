<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/nodejitsu/forever-monitor#readme">forever-monitor (v1.7.1)</a>
</h1>
<h4>Core forever process monitor</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor">module forever-monitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor">
            function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor
            <span class="apidocSignatureSpan">(script, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_">
            function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.checkProcess">
            function <span class="apidocSignatureSpan">forever-monitor.</span>checkProcess
            <span class="apidocSignatureSpan">(pid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.kill">
            function <span class="apidocSignatureSpan">forever-monitor.</span>kill
            <span class="apidocSignatureSpan">(pid, killTree, signal, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.start">
            function <span class="apidocSignatureSpan">forever-monitor.</span>start
            <span class="apidocSignatureSpan">(script, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.super_.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>logger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>monitor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>watch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">forever-monitor.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor">module forever-monitor.Monitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.Monitor">
            function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor
            <span class="apidocSignatureSpan">(script, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.parseCommand">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>parseCommand
            <span class="apidocSignatureSpan">(command, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor.prototype">module forever-monitor.Monitor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype._getEnv">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>_getEnv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.kill">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>kill
            <span class="apidocSignatureSpan">(forceStop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.restart">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>restart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.send">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>send
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.start">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>start
            <span class="apidocSignatureSpan">(restart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.stop">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.toString">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.trySpawn">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>trySpawn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>inspect</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor.super_">module forever-monitor.Monitor.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>super_
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor.super_.prototype">module forever-monitor.Monitor.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.prototype.init">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>init
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.prototype.inspect">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.prototype.remove">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>remove
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.prototype.use">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>use
            <span class="apidocSignatureSpan">(plugin, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor.super_.super_.prototype">module forever-monitor.Monitor.super_.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.addListener">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.emit">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listeners">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listenersAny">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>listenersAny
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.many">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>many
            <span class="apidocSignatureSpan">(event, ttl, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.off">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>off
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.offAny">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>offAny
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.on">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.onAny">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>onAny
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.once">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeListener">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>delimiter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>event</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.common">module forever-monitor.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.common.checkProcess">
            function <span class="apidocSignatureSpan">forever-monitor.common.</span>checkProcess
            <span class="apidocSignatureSpan">(pid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.common.kill">
            function <span class="apidocSignatureSpan">forever-monitor.common.</span>kill
            <span class="apidocSignatureSpan">(pid, killTree, signal, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.logger">module forever-monitor.logger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.logger.attach">
            function <span class="apidocSignatureSpan">forever-monitor.logger.</span>attach
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">forever-monitor.logger.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.monitor">module forever-monitor.monitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.monitor.Monitor">
            function <span class="apidocSignatureSpan">forever-monitor.monitor.</span>Monitor
            <span class="apidocSignatureSpan">(script, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.watch">module forever-monitor.watch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.watch.attach">
            function <span class="apidocSignatureSpan">forever-monitor.watch.</span>attach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">forever-monitor.watch.</span>name</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor" id="apidoc.module.forever-monitor">module forever-monitor</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor" id="apidoc.element.forever-monitor.Monitor">
        function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor
        <span class="apidocSignatureSpan">(script, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Monitor = function (script, options) {
  //
  // Simple bootstrapper for attaching logger
  // and watch plugins by default. Other plugins
  // can be attached through `monitor.use(plugin, options)`.
  //
  function bootstrap(monitor) {
    plugins.logger.attach.call(monitor, options);
    if (options.watch) {
      plugins.watch.attach.call(monitor, options);
    }
  }

  var execPath = process.execPath,
      self     = this;

  //
  // Setup basic configuration options
  //
  options               = options || {};
  this.silent           = options.silent || false;
  this.killTree         = options.killTree !== false;
  this.uid              = options.uid || utile.randomString(4);
  this.id               = options.id || false;
  this.pidFile          = options.pidFile;
  this.max              = options.max;
  this.killTTL          = options.killTTL;
  this.killSignal       = options.killSignal || 'SIGKILL';
  this.childExists      = false;
  this.checkFile        = options.checkFile !== false;
  this.times            = 0;
  this.warn             = console.error;

  this.logFile          = options.logFile;
  this.outFile          = options.outFile;
  this.errFile          = options.errFile;
  this.append           = options.append;
  this.usePolling       = options.usePolling;
  this.pollingInterval  = options.pollingInterval;

  //
  // Define some safety checks for commands with spaces
  //
  this.parser = options.parser || Monitor.parseCommand;

  //
  // Setup restart timing. These options control how quickly forever restarts
  // a child process as well as when to kill a "spinning" process
  //
  this.minUptime     = typeof options.minUptime !== 'number' ? 0 : options.minUptime;
  this.spinSleepTime = options.spinSleepTime || null;

  //
  // Special case Windows separately to decouple any
  // future changes
  //
  if (process.platform === 'win32') {
    execPath = '"' + execPath + '"';
  }

  if (options.options) {
    console.warn('options.options is deprecated. Use options.args instead.');
  }

  //
  // Setup the command to spawn and the options to pass
  // to that command.
  //
  this.command   = options.command || execPath;
  this.args      = options.args || options.options || [];
  this.spawnWith = options.spawnWith || {};
  this.sourceDir = options.sourceDir;
  this.fork      = options.fork || false;
  this.cwd       = options.cwd || process.cwd();
  this.hideEnv   = options.hideEnv || [];
  this._env      = options.env || {};
  this._hideEnv  = {};

  //
  // Allow for custom stdio configuration of forked processes
  //
  this.stdio = options.stdio || null;

  //
  // Setup watch configuration options
  //
  this.watchIgnoreDotFiles = options.watchIgnoreDotFiles !== false;
  this.watchIgnorePatterns = options.watchIgnorePatterns || [];
  this.watchDirectory      = options.watchDirectory || this.sourceDir;

  //
  // Create a simple mapping of `this.hideEnv` to an easily indexable
  // object
  //
  this.hideEnv.forEach(function (key) {
    self._hideEnv[key] = true;
  });

  if (Array.isArray(script)) {
    this.command = script[0];
    this.args = script.slice(1);
  }
  else {
    this.args.unshift(script);
  }

  if (this.sourceDir) {
    this.args[0] = path.join(this.sourceDir, this.args[0]);
  }

  //
  // Bootstrap this instance now that options
  // have been set
  //
  broadway.App.call(this, { bootstrapper: { bootstrap: bootstrap } });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Starts a script with forever
//
exports.start = function (script, options) {
  if (!options.uid) {
    options.uid = options.uid || utile.randomString(4).replace(/^\-/, '_');
  }

  return new exports.<span class="apidocCodeKeywordSpan">Monitor</span>(script, options).start();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_" id="apidoc.element.forever-monitor.Monitor.super_">
        function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Monitor.super_ = function (options) {
  //
  // Setup options and `App` constants.
  //
  options        = options || {};
  this.root      = options.root;
  this.delimiter = options.delimiter || '::';

  //
  // Inherit from `EventEmitter2`
  //
  events.EventEmitter2.call(this, {
    delimiter: this.delimiter,
    wildcard: true
  });

  //
  // Setup other relevant options such as the plugins
  // for this instance.
  //
  this.options      = options;
  this.env          = options.env || process.env['NODE_ENV'] || 'development'
  this.plugins      = options.plugins || {};
  this.initialized  = false;
  this.bootstrapper = options.bootstrapper || bootstrapper;
  this.initializers = {};
  this.initlist     = [];

  //
  // Bootstrap this instance
  //
  this.bootstrapper.bootstrap(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.checkProcess" id="apidoc.element.forever-monitor.checkProcess">
        function <span class="apidocSignatureSpan">forever-monitor.</span>checkProcess
        <span class="apidocSignatureSpan">(pid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkProcess = function (pid) {
  if (!pid) {
    return false;
  }

  try {
    //
    // Trying to kill non-existent process here raises a ESRCH - no such
    // process exception. Also, signal 0 doesn't do no harm to a process - it
    // only checks if sending a signal to a given process is possible.
    //
    process.kill(pid, 0);
    return true;
  }
  catch (err) {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...






/*
 * check-process-test.js: Tests for forever.<span class="apidocCodeKeywordSpan">checkProcess</span>(pid)
 *
 * (C) 2010 Charlie Robbins &amp; the Contributors
 * MIT LICENCE
 *
 */

var assert = require('assert'),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.kill" id="apidoc.element.forever-monitor.kill">
        function <span class="apidocSignatureSpan">forever-monitor.</span>kill
        <span class="apidocSignatureSpan">(pid, killTree, signal, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (pid, killTree, signal, callback) {
  signal   = signal   || 'SIGKILL';
  callback = callback || function () {};

  if (killTree &amp;&amp; process.platform !== 'win32') {
    psTree(pid, function (err, children) {
      [pid].concat(
        children.map(function (p) {
          return p.PID;
        })
      ).forEach(function (tpid) {
        try { process.kill(tpid, signal) }
        catch (ex) { }
      });

      callback();
    });
  }
  else {
    try { process.kill(pid, signal) }
    catch (ex) { }
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  try {
    //
    // Trying to kill non-existent process here raises a ESRCH - no such
    // process exception. Also, signal 0 doesn't do no harm to a process - it
    // only checks if sending a signal to a given process is possible.
    //
    process.<span class="apidocCodeKeywordSpan">kill</span>(pid, 0);
    return true;
  }
  catch (err) {
    return false;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.start" id="apidoc.element.forever-monitor.start">
        function <span class="apidocSignatureSpan">forever-monitor.</span>start
        <span class="apidocSignatureSpan">(script, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (script, options) {
  if (!options.uid) {
    options.uid = options.uid || utile.randomString(4).replace(/^\-/, '_');
  }

  return new exports.Monitor(script, options).start();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args: []
  });

  child.on('exit', function () {
    console.log('your-filename.js has exited after 3 restarts');
  });

  child.<span class="apidocCodeKeywordSpan">start</span>();
```

### Spawning a non-node process
You can spawn non-node processes too. Either set the `command` key in the
`options` hash or pass in an `Array` in place of the `file` argument like this:

``` js
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor" id="apidoc.module.forever-monitor.Monitor">module forever-monitor.Monitor</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.Monitor" id="apidoc.element.forever-monitor.Monitor.Monitor">
        function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor
        <span class="apidocSignatureSpan">(script, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Monitor = function (script, options) {
  //
  // Simple bootstrapper for attaching logger
  // and watch plugins by default. Other plugins
  // can be attached through `monitor.use(plugin, options)`.
  //
  function bootstrap(monitor) {
    plugins.logger.attach.call(monitor, options);
    if (options.watch) {
      plugins.watch.attach.call(monitor, options);
    }
  }

  var execPath = process.execPath,
      self     = this;

  //
  // Setup basic configuration options
  //
  options               = options || {};
  this.silent           = options.silent || false;
  this.killTree         = options.killTree !== false;
  this.uid              = options.uid || utile.randomString(4);
  this.id               = options.id || false;
  this.pidFile          = options.pidFile;
  this.max              = options.max;
  this.killTTL          = options.killTTL;
  this.killSignal       = options.killSignal || 'SIGKILL';
  this.childExists      = false;
  this.checkFile        = options.checkFile !== false;
  this.times            = 0;
  this.warn             = console.error;

  this.logFile          = options.logFile;
  this.outFile          = options.outFile;
  this.errFile          = options.errFile;
  this.append           = options.append;
  this.usePolling       = options.usePolling;
  this.pollingInterval  = options.pollingInterval;

  //
  // Define some safety checks for commands with spaces
  //
  this.parser = options.parser || Monitor.parseCommand;

  //
  // Setup restart timing. These options control how quickly forever restarts
  // a child process as well as when to kill a "spinning" process
  //
  this.minUptime     = typeof options.minUptime !== 'number' ? 0 : options.minUptime;
  this.spinSleepTime = options.spinSleepTime || null;

  //
  // Special case Windows separately to decouple any
  // future changes
  //
  if (process.platform === 'win32') {
    execPath = '"' + execPath + '"';
  }

  if (options.options) {
    console.warn('options.options is deprecated. Use options.args instead.');
  }

  //
  // Setup the command to spawn and the options to pass
  // to that command.
  //
  this.command   = options.command || execPath;
  this.args      = options.args || options.options || [];
  this.spawnWith = options.spawnWith || {};
  this.sourceDir = options.sourceDir;
  this.fork      = options.fork || false;
  this.cwd       = options.cwd || process.cwd();
  this.hideEnv   = options.hideEnv || [];
  this._env      = options.env || {};
  this._hideEnv  = {};

  //
  // Allow for custom stdio configuration of forked processes
  //
  this.stdio = options.stdio || null;

  //
  // Setup watch configuration options
  //
  this.watchIgnoreDotFiles = options.watchIgnoreDotFiles !== false;
  this.watchIgnorePatterns = options.watchIgnorePatterns || [];
  this.watchDirectory      = options.watchDirectory || this.sourceDir;

  //
  // Create a simple mapping of `this.hideEnv` to an easily indexable
  // object
  //
  this.hideEnv.forEach(function (key) {
    self._hideEnv[key] = true;
  });

  if (Array.isArray(script)) {
    this.command = script[0];
    this.args = script.slice(1);
  }
  else {
    this.args.unshift(script);
  }

  if (this.sourceDir) {
    this.args[0] = path.join(this.sourceDir, this.args[0]);
  }

  //
  // Bootstrap this instance now that options
  // have been set
  //
  broadway.App.call(this, { bootstrapper: { bootstrap: bootstrap } });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Starts a script with forever
//
exports.start = function (script, options) {
  if (!options.uid) {
    options.uid = options.uid || utile.randomString(4).replace(/^\-/, '_');
  }

  return new exports.<span class="apidocCodeKeywordSpan">Monitor</span>(script, options).start();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.parseCommand" id="apidoc.element.forever-monitor.Monitor.parseCommand">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>parseCommand
        <span class="apidocSignatureSpan">(command, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCommand = function (command, args) {
  var match = command.match(
    process.platform === 'win32' ? safetyChecks.windows : safetyChecks.linux
  );

  //
  // No match means it's a bad command. This is configurable
  // by passing a custom `parser` function into the `Monitor`
  // constructor function.
  //
  if (!match) { return false; }

  if (process.platform == 'win32') {
    command = match[1] || match[2];
    if (match[3]) {
      args = match[3].split(' ').concat(args);
    }
  } else {
    command = match[1];
    if (match[2]) {
      args = match[2].split(' ').concat(this.args);
    }
  }

  return {
    command: command,
    args:    args
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_" id="apidoc.element.forever-monitor.Monitor.super_">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (options) {
  //
  // Setup options and `App` constants.
  //
  options        = options || {};
  this.root      = options.root;
  this.delimiter = options.delimiter || '::';

  //
  // Inherit from `EventEmitter2`
  //
  events.EventEmitter2.call(this, {
    delimiter: this.delimiter,
    wildcard: true
  });

  //
  // Setup other relevant options such as the plugins
  // for this instance.
  //
  this.options      = options;
  this.env          = options.env || process.env['NODE_ENV'] || 'development'
  this.plugins      = options.plugins || {};
  this.initialized  = false;
  this.bootstrapper = options.bootstrapper || bootstrapper;
  this.initializers = {};
  this.initlist     = [];

  //
  // Bootstrap this instance
  //
  this.bootstrapper.bootstrap(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor.prototype" id="apidoc.module.forever-monitor.Monitor.prototype">module forever-monitor.Monitor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype._getEnv" id="apidoc.element.forever-monitor.Monitor.prototype._getEnv">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>_getEnv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getEnv = function () {
  var self = this,
      merged = {};

  function addKey(key, source) {
    merged[key] = source[key];
  }

  //
  // Mixin the key:value pairs from `process.env` and the custom
  // environment variables in `this._env`.
  //
  Object.keys(process.env).forEach(function (key) {
    if (!self._hideEnv[key]) {
      addKey(key, process.env);
    }
  });

  Object.keys(this._env).forEach(function (key) {
    addKey(key, self._env);
  });

  return merged;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  catch (ex) {
    return false;
  }
}

this.spawnWith.cwd = this.spawnWith.cwd || this.cwd;
this.spawnWith.env = this.<span class="apidocCodeKeywordSpan">_getEnv</span>();

if (process.platform === 'win32') {
  this.spawnWith.detached = true;
}

if (this.stdio) {
  this.spawnWith.stdio = this.stdio;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.kill" id="apidoc.element.forever-monitor.Monitor.prototype.kill">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>kill
        <span class="apidocSignatureSpan">(forceStop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (forceStop) {
  var child = this.child,
      self = this,
      timer;

  if (!child || (!this.running &amp;&amp; !this.forceRestart)) {
    process.nextTick(function () {
      self.emit('error', new Error('Cannot stop process that is not running.'));
    });
  }
  else {
    //
    // Set an instance variable here to indicate this
    // stoppage is forced so that when `child.on('exit', ..)`
    // fires in `Monitor.prototype.start` we can short circuit
    // and prevent auto-restart
    //
    if (forceStop) {
      this.forceStop = true;
      //
      // If we have a time before we truly kill forcefully, set up a timer
      //
      if (this.killTTL) {
        timer = setTimeout(function () {
          common.kill(self.child.pid, self.killTree, self.killSignal || 'SIGKILL');
        }, this.killTTL);

        child.once('exit', function () {
          clearTimeout(timer);
        });
      }
    }

    child.once('exit', function () {
      self.emit('stop', self.childData);
      if (self.forceRestart &amp;&amp; !self.running) {
        self.start(true);
      }
    });

    common.kill(this.child.pid, this.killTree, this.killSignal);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  try {
    //
    // Trying to kill non-existent process here raises a ESRCH - no such
    // process exception. Also, signal 0 doesn't do no harm to a process - it
    // only checks if sending a signal to a given process is possible.
    //
    process.<span class="apidocCodeKeywordSpan">kill</span>(pid, 0);
    return true;
  }
  catch (err) {
    return false;
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.restart" id="apidoc.element.forever-monitor.Monitor.prototype.restart">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>restart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restart = function () {
  this.times = this.times || 0;
  this.forceRestart = true;

  return !this.running
    ? this.start(true)
    : this.kill(false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  assert.isFunction(child.stop);
},
"calling the restart() method in less than `minUptime`": {
  topic: function (child) {
    var that = this;
    child.once('start', function () {
      child.once('restart', that.callback.bind(this, null));
      child.<span class="apidocCodeKeywordSpan">restart</span>();
    });
    child.start();
  },
  "should restart the child process": function (_, child, data) {
    assert.isObject(data);
    child.kill(true);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.send" id="apidoc.element.forever-monitor.Monitor.prototype.send">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>send
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (msg) {
  var child = this.child,
      self = this;

  if (!child || !this.running) {
    process.nextTick(function () {
      self.emit('error', new Error('Cannot send to process that is not running.'));
    });
  }

  if (child.send) { child.send(msg) }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...





setInterval(function () {
  if (process.send) {
    process.<span class="apidocCodeKeywordSpan">send</span>({ from: 'child' });
  }
}, 1000)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.start" id="apidoc.element.forever-monitor.Monitor.prototype.start">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>start
        <span class="apidocSignatureSpan">(restart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (restart) {
  var self = this,
      child;

  if (this.running &amp;&amp; !restart) {
    process.nextTick(function () {
      self.emit('error', new Error('Cannot start process that is already running.'));
    });
    return this;
  }

  child = this.trySpawn();
  if (!child) {
    process.nextTick(function () {
      self.emit('error', new Error('Target script does not exist: ' + self.args[0]));
    });
    return this;
  }

  this.ctime = Date.now();
  this.child = child;
  this.running = true;
  this.isMaster = cluster.isMaster;

  process.nextTick(function () {
    self.emit(restart ? 'restart' : 'start', self, self.data);
  });

  function onMessage(msg) {
    self.emit('message', msg);
  }

  // Re-emit messages from the child process
  this.child.on('message', onMessage);

  child.on('exit', function (code, signal) {
    var spinning = Date.now() - self.ctime &lt; self.minUptime;
    child.removeListener('message', onMessage);
    self.emit('exit:code', code, signal);

    function letChildDie() {
      self.running = false;
      self.forceStop = false;
      self.emit('exit', self, spinning);
    }

    function restartChild() {
      self.forceRestart = false;
      process.nextTick(function () {
        self.start(true);
      });
    }

    self.times++;

    if (self.forceStop || (self.times &gt;= self.max &amp;&amp; !self.forceRestart)
      || (spinning &amp;&amp; typeof self.spinSleepTime !== 'number') &amp;&amp; !self.forceRestart) {
      letChildDie();
    }
    else if (spinning) {
      setTimeout(restartChild, self.spinSleepTime);
    }
    else {
      restartChild();
    }
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args: []
  });

  child.on('exit', function () {
    console.log('your-filename.js has exited after 3 restarts');
  });

  child.<span class="apidocCodeKeywordSpan">start</span>();
```

### Spawning a non-node process
You can spawn non-node processes too. Either set the `command` key in the
`options` hash or pass in an `Array` in place of the `file` argument like this:

``` js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.stop" id="apidoc.element.forever-monitor.Monitor.prototype.stop">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function () {
  return this.kill(true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });

  child.on('start', function () {
    //
    // Give it time to set up signal handlers
    //
    setTimeout(function () {
      child.<span class="apidocCodeKeywordSpan">stop</span>();
    }, 1000);
  });

  child.start();
},
"should forcibly kill the processes": function (err, child, spinning) {
  assert.isNull(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.toString" id="apidoc.element.forever-monitor.Monitor.prototype.toString">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return JSON.stringify(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    max: 1,
    silent: true,
    minUptime: 0,
    env: this.env
  });

  child.on('stdout', function (data) {
    that.stdout = data.<span class="apidocCodeKeywordSpan">toString</span>();
  });

  child.on('exit', this.callback.bind({}, null));
  child.start();
},
"should pass the environment variables to the child": function (err, child) {
  assert.equal(child.times, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.trySpawn" id="apidoc.element.forever-monitor.Monitor.prototype.trySpawn">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>trySpawn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trySpawn = function () {
  var run = this.parser(this.command, this.args.slice()),
      stats;

  if (/[^\w]node$/.test(this.command) &amp;&amp; this.checkFile &amp;&amp; !this.childExists) {
    try {
      stats = fs.statSync(this.args[0]);
      this.childExists = true;
    }
    catch (ex) {
      return false;
    }
  }

  this.spawnWith.cwd = this.spawnWith.cwd || this.cwd;
  this.spawnWith.env = this._getEnv();

  if (process.platform === 'win32') {
    this.spawnWith.detached = true;
  }

  if (this.stdio) {
    this.spawnWith.stdio = this.stdio;
  }

  if (this.fork) {
    if (!this.stdio) {
      this.spawnWith.stdio = [ 'pipe', 'pipe', 'pipe', 'ipc' ];
    }
    return spawn(run.command, run.args, this.spawnWith);
  }

  return spawn(run.command, run.args, this.spawnWith);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.running &amp;&amp; !restart) {
  process.nextTick(function () {
    self.emit('error', new Error('Cannot start process that is already running.'));
  });
  return this;
}

child = this.<span class="apidocCodeKeywordSpan">trySpawn</span>();
if (!child) {
  process.nextTick(function () {
    self.emit('error', new Error('Target script does not exist: ' + self.args[0]));
  });
  return this;
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor.super_" id="apidoc.module.forever-monitor.Monitor.super_">module forever-monitor.Monitor.super_</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_" id="apidoc.element.forever-monitor.Monitor.super_.super_">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>super_
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(conf) {
  this._events = {};
  this.newListener = false;
  configure.call(this, conf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor.super_.prototype" id="apidoc.module.forever-monitor.Monitor.super_.prototype">module forever-monitor.Monitor.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.prototype.init" id="apidoc.element.forever-monitor.Monitor.super_.prototype.init">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>init
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (options, callback) {
  if (!callback &amp;&amp; typeof options === 'function') {
    callback = options;
    options = {};
  }

  if (this.initialized) {
    return callback();
  }

  var self = this;
  options = options   || {};
  callback = callback || function () {};
  this.env = options.env || this.env;
  this.options = common.mixin({}, this.options, options);

  function onComplete() {
    self.initialized = true;
    self.emit('init');
    callback();
  }

  function ensureFeatures (err) {
    return err
      ? onError(err)
      : features.ensure(this, onComplete);
  }

  function initPlugin(plugin, next) {
    if (typeof self.initializers[plugin] === 'function') {
      return self.initializers[plugin].call(self, function (err) {
        if (err) {
          return next(err);
        }

        self.emit(['plugin', plugin, 'init']);
        self.initializers[plugin] = true;
        next();
      });
    }

    next();
  }

  function initPlugins() {
    async.forEach(self.initlist, initPlugin, ensureFeatures);
  }

  //
  // Emit and respond with any errors that may short
  // circuit the process.
  //
  function onError(err) {
    self.emit(['error', 'init'], err);
    callback(err);
  }

  //
  // Run the bootstrapper, initialize plugins, and
  // ensure features for this instance.
  //
  this.bootstrapper.init(this, initPlugins);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.prototype.inspect" id="apidoc.element.forever-monitor.Monitor.super_.prototype.inspect">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.prototype.remove" id="apidoc.element.forever-monitor.Monitor.super_.prototype.remove">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>remove
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (name) {
  // if this is a plugin object set the name to the plugins name
  if (name.name) {
    name = name.name;
  }

  if (this.plugins[name] &amp;&amp; this.plugins[name].detach) {
    this.plugins[name].detach.call(this);
  }

  delete this.plugins[name];
  delete this.options[name];
  delete this.initializers[name];

  var init = this.initlist.indexOf(name);

  if (init !== -1) {
    this.initlist.splice(1, init);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.prototype.use" id="apidoc.element.forever-monitor.Monitor.super_.prototype.use">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>use
        <span class="apidocSignatureSpan">(plugin, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (plugin, options, callback) {
  options = options || {};

  if (typeof plugin === 'undefined') {
    console.log('Cannot load invalid plugin!');
    return callback &amp;&amp; callback(new Error('Invalid plugin'));
  }

  var name = plugin.name,
      self = this;

  // If the plugin doesn't have a name, use itself as an identifier for the plugins hash.
  if (!name) {
    name = common.uuid();
  }

  if (this.plugins[name]) {
    return callback &amp;&amp; callback();
  }

  //
  // Setup state on this instance for the specified plugin
  //
  this.plugins[name] = plugin;
  this.options[name] = common.mixin({}, options, this.options[name] || {});

  //
  // Attach the specified plugin to this instance, extending
  // the `App` with new functionality.
  //
  if (this.plugins[name].attach &amp;&amp; options.attach !== false) {
    this.plugins[name].attach.call(this, options);
  }

  //
  // Setup the initializer only if `options.init` is
  // not false. This allows for some plugins to be lazy-loaded
  //
  if (options.init === false) {
    return callback &amp;&amp; callback();
  }

  if (!this.initialized) {
    this.initializers[name] = plugin.init || true;
    this.initlist.push(name);
    return callback &amp;&amp; callback();
  }
  else if (plugin.init) {
    plugin.init.call(this, function (err) {
      var args = err
        ? [['plugin', name, 'error'], err]
        : [['plugin', name, 'init']];

      self.emit.apply(self, args);
      return callback &amp;&amp; (err ? callback(err) : callback());
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// #### @options {Object} Configuration for this instance.
// Creates a new instance of forever with specified `options`.
//
var Monitor = exports.Monitor = function (script, options) {
//
// Simple bootstrapper for attaching logger
// and watch plugins by default. Other plugins
// can be attached through `monitor.<span class="apidocCodeKeywordSpan">use</span>(plugin, options)`.
//
function bootstrap(monitor) {
  plugins.logger.attach.call(monitor, options);
  if (options.watch) {
    plugins.watch.attach.call(monitor, options);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor.super_.super_.prototype" id="apidoc.module.forever-monitor.Monitor.super_.super_.prototype">module forever-monitor.Monitor.super_.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.addListener" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.addListener">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (type, listener) {

  if (typeof type === 'function') {
    this.onAny(type);
    return this;
  }

  if (typeof listener !== 'function') {
    throw new Error('on only accepts instances of Function');
  }
  this._events || init.call(this);

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if(this.wildcard) {
    growListenerTree.call(this, type, listener);
    return this;
  }

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  }
  else if(typeof this._events[type] === 'function') {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }
  else if (isArray(this._events[type])) {
    // If we've already got an array, just append.
    this._events[type].push(listener);

    // Check for listener leak
    if (!this._events[type].warned) {

      var m = defaultMaxListeners;

      if (typeof this._events.maxListeners !== 'undefined') {
        m = this._events.maxListeners;
      }

      if (m &gt; 0 &amp;&amp; this._events[type].length &gt; m) {

        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.emit" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.emit">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () {

  this._events || init.call(this);

  var type = arguments[0];

  if (type === 'newListener' &amp;&amp; !this.newListener) {
    if (!this._events.newListener) { return false; }
  }

  // Loop through the *_all* functions and invoke them.
  if (this._all) {
    var l = arguments.length;
    var args = new Array(l - 1);
    for (var i = 1; i &lt; l; i++) args[i - 1] = arguments[i];
    for (i = 0, l = this._all.length; i &lt; l; i++) {
      this.event = type;
      this._all[i].apply(this, args);
    }
  }

  // If there is no 'error' event listener then throw.
  if (type === 'error') {

    if (!this._all &amp;&amp;
      !this._events.error &amp;&amp;
      !(this.wildcard &amp;&amp; this.listenerTree.error)) {

      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  var handler;

  if(this.wildcard) {
    handler = [];
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
  }
  else {
    handler = this._events[type];
  }

  if (typeof handler === 'function') {
    this.event = type;
    if (arguments.length === 1) {
      handler.call(this);
    }
    else if (arguments.length &gt; 1)
      switch (arguments.length) {
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          var l = arguments.length;
          var args = new Array(l - 1);
          for (var i = 1; i &lt; l; i++) args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    return true;
  }
  else if (handler) {
    var l = arguments.length;
    var args = new Array(l - 1);
    for (var i = 1; i &lt; l; i++) args[i - 1] = arguments[i];

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i &lt; l; i++) {
      this.event = type;
      listeners[i].apply(this, args);
    }
    return (listeners.length &gt; 0) || !!this._all;
  }
  else {
    return !!this._all;
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
Monitor.prototype.start = function (restart) {
var self = this,
    child;

if (this.running &amp;&amp; !restart) {
  process.nextTick(function () {
    self.<span class="apidocCodeKeywordSpan">emit</span>('error', new Error('Cannot start process that is already
 running.'));
  });
  return this;
}

child = this.trySpawn();
if (!child) {
  process.nextTick(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listeners" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listeners">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function (type) {
  if(this.wildcard) {
    var handlers = [];
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
    return handlers;
  }

  this._events || init.call(this);

  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listenersAny" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listenersAny">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>listenersAny
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenersAny = function () {

  if(this._all) {
    return this._all;
  }
  else {
    return [];
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.many" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.many">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>many
        <span class="apidocSignatureSpan">(event, ttl, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">many = function (event, ttl, fn) {
  var self = this;

  if (typeof fn !== 'function') {
    throw new Error('many only accepts instances of Function');
  }

  function listener() {
    if (--ttl === 0) {
      self.off(event, listener);
    }
    fn.apply(this, arguments);
  }

  listener._origin = fn;

  this.on(event, listener);

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.off" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.off">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>off
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (type, listener) {
  if (typeof listener !== 'function') {
    throw new Error('removeListener only takes instances of Function');
  }

  var handlers,leafs=[];

  if(this.wildcard) {
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
  }
  else {
    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events[type]) return this;
    handlers = this._events[type];
    leafs.push({_listeners:handlers});
  }

  for (var iLeaf=0; iLeaf&lt;leafs.length; iLeaf++) {
    var leaf = leafs[iLeaf];
    handlers = leaf._listeners;
    if (isArray(handlers)) {

      var position = -1;

      for (var i = 0, length = handlers.length; i &lt; length; i++) {
        if (handlers[i] === listener ||
          (handlers[i].listener &amp;&amp; handlers[i].listener === listener) ||
          (handlers[i]._origin &amp;&amp; handlers[i]._origin === listener)) {
          position = i;
          break;
        }
      }

      if (position &lt; 0) {
        continue;
      }

      if(this.wildcard) {
        leaf._listeners.splice(position, 1);
      }
      else {
        this._events[type].splice(position, 1);
      }

      if (handlers.length === 0) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
      return this;
    }
    else if (handlers === listener ||
      (handlers.listener &amp;&amp; handlers.listener === listener) ||
      (handlers._origin &amp;&amp; handlers._origin === listener)) {
      if(this.wildcard) {
        delete leaf._listeners;
      }
      else {
        delete this._events[type];
      }
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.offAny" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.offAny">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>offAny
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offAny = function (fn) {
  var i = 0, l = 0, fns;
  if (fn &amp;&amp; this._all &amp;&amp; this._all.length &gt; 0) {
    fns = this._all;
    for(i = 0, l = fns.length; i &lt; l; i++) {
      if(fn === fns[i]) {
        fns.splice(i, 1);
        return this;
      }
    }
  } else {
    this._all = [];
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.on" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.on">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (type, listener) {

  if (typeof type === 'function') {
    this.onAny(type);
    return this;
  }

  if (typeof listener !== 'function') {
    throw new Error('on only accepts instances of Function');
  }
  this._events || init.call(this);

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if(this.wildcard) {
    growListenerTree.call(this, type, listener);
    return this;
  }

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  }
  else if(typeof this._events[type] === 'function') {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }
  else if (isArray(this._events[type])) {
    // If we've already got an array, just append.
    this._events[type].push(listener);

    // Check for listener leak
    if (!this._events[type].warned) {

      var m = defaultMaxListeners;

      if (typeof this._events.maxListeners !== 'undefined') {
        m = this._events.maxListeners;
      }

      if (m &gt; 0 &amp;&amp; this._events[type].length &gt; m) {

        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var child = new (forever.Monitor)('your-filename.js', {
    max: 3,
    silent: true,
    args: []
  });

  child.<span class="apidocCodeKeywordSpan">on</span>('exit', function () {
    console.log('your-filename.js has exited after 3 restarts');
  });

  child.start();
```

### Spawning a non-node process
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.onAny" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.onAny">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>onAny
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onAny = function (fn) {

  if (typeof fn !== 'function') {
    throw new Error('onAny only accepts instances of Function');
  }

  if(!this._all) {
    this._all = [];
  }

  // Add the function to the event listener collection.
  this._all.push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.once" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.once">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (event, fn) {
  this.many(event, 1, fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // If we have a time before we truly kill forcefully, set up a timer
  //
  if (this.killTTL) {
    timer = setTimeout(function () {
      common.kill(self.child.pid, self.killTree, self.killSignal || 'SIGKILL');
    }, this.killTTL);

    child.<span class="apidocCodeKeywordSpan">once</span>('exit', function () {
      clearTimeout(timer);
    });
  }
}

child.once('exit', function () {
  self.emit('stop', self.childData);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeAllListeners" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function (type) {
  if (arguments.length === 0) {
    !this._events || init.call(this);
    return this;
  }

  if(this.wildcard) {
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

    for (var iLeaf=0; iLeaf&lt;leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      leaf._listeners = null;
    }
  }
  else {
    if (!this._events[type]) return this;
    this._events[type] = null;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeListener" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeListener">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (type, listener) {
  if (typeof listener !== 'function') {
    throw new Error('removeListener only takes instances of Function');
  }

  var handlers,leafs=[];

  if(this.wildcard) {
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
  }
  else {
    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events[type]) return this;
    handlers = this._events[type];
    leafs.push({_listeners:handlers});
  }

  for (var iLeaf=0; iLeaf&lt;leafs.length; iLeaf++) {
    var leaf = leafs[iLeaf];
    handlers = leaf._listeners;
    if (isArray(handlers)) {

      var position = -1;

      for (var i = 0, length = handlers.length; i &lt; length; i++) {
        if (handlers[i] === listener ||
          (handlers[i].listener &amp;&amp; handlers[i].listener === listener) ||
          (handlers[i]._origin &amp;&amp; handlers[i]._origin === listener)) {
          position = i;
          break;
        }
      }

      if (position &lt; 0) {
        continue;
      }

      if(this.wildcard) {
        leaf._listeners.splice(position, 1);
      }
      else {
        this._events[type].splice(position, 1);
      }

      if (handlers.length === 0) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
      return this;
    }
    else if (handlers === listener ||
      (handlers.listener &amp;&amp; handlers.listener === listener) ||
      (handlers._origin &amp;&amp; handlers._origin === listener)) {
      if(this.wildcard) {
        delete leaf._listeners;
      }
      else {
        delete this._events[type];
      }
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // Re-emit messages from the child process
  this.child.on('message', onMessage);

  child.on('exit', function (code, signal) {
var spinning = Date.now() - self.ctime &lt; self.minUptime;
child.<span class="apidocCodeKeywordSpan">removeListener</span>('message', onMessage);
self.emit('exit:code', code, signal);

function letChildDie() {
  self.running = false;
  self.forceStop = false;
  self.emit('exit', self, spinning);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.setMaxListeners" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function (n) {
  this._events || init.call(this);
  this._events.maxListeners = n;
  if (!this._conf) this._conf = {};
  this._conf.maxListeners = n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

monitor.child.stderr.on('data', function onStderr(data) {
  monitor.emit('stderr', data);
});

if (!monitor.silent) {
  process.stdout.<span class="apidocCodeKeywordSpan">setMaxListeners</span>(0);
  process.stderr.setMaxListeners(0);
  monitor.child.stdout.pipe(process.stdout, { end: false });
  monitor.child.stderr.pipe(process.stderr, { end: false });
}

if (monitor.stdout) {
  monitor.child.stdout.pipe(monitor.stdout, { end: false });
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.common" id="apidoc.module.forever-monitor.common">module forever-monitor.common</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.common.checkProcess" id="apidoc.element.forever-monitor.common.checkProcess">
        function <span class="apidocSignatureSpan">forever-monitor.common.</span>checkProcess
        <span class="apidocSignatureSpan">(pid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkProcess = function (pid) {
  if (!pid) {
    return false;
  }

  try {
    //
    // Trying to kill non-existent process here raises a ESRCH - no such
    // process exception. Also, signal 0 doesn't do no harm to a process - it
    // only checks if sending a signal to a given process is possible.
    //
    process.kill(pid, 0);
    return true;
  }
  catch (err) {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...






/*
 * check-process-test.js: Tests for forever.<span class="apidocCodeKeywordSpan">checkProcess</span>(pid)
 *
 * (C) 2010 Charlie Robbins &amp; the Contributors
 * MIT LICENCE
 *
 */

var assert = require('assert'),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.common.kill" id="apidoc.element.forever-monitor.common.kill">
        function <span class="apidocSignatureSpan">forever-monitor.common.</span>kill
        <span class="apidocSignatureSpan">(pid, killTree, signal, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (pid, killTree, signal, callback) {
  signal   = signal   || 'SIGKILL';
  callback = callback || function () {};

  if (killTree &amp;&amp; process.platform !== 'win32') {
    psTree(pid, function (err, children) {
      [pid].concat(
        children.map(function (p) {
          return p.PID;
        })
      ).forEach(function (tpid) {
        try { process.kill(tpid, signal) }
        catch (ex) { }
      });

      callback();
    });
  }
  else {
    try { process.kill(pid, signal) }
    catch (ex) { }
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  try {
    //
    // Trying to kill non-existent process here raises a ESRCH - no such
    // process exception. Also, signal 0 doesn't do no harm to a process - it
    // only checks if sending a signal to a given process is possible.
    //
    process.<span class="apidocCodeKeywordSpan">kill</span>(pid, 0);
    return true;
  }
  catch (err) {
    return false;
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.logger" id="apidoc.module.forever-monitor.logger">module forever-monitor.logger</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.logger.attach" id="apidoc.element.forever-monitor.logger.attach">
        function <span class="apidocSignatureSpan">forever-monitor.logger.</span>attach
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attach = function (options) {
  options = options || {};
  var monitor = this;

  if (options.outFile) {
    monitor.stdout = options.stdout || fs.createWriteStream(options.outFile, {
      flags: monitor.append ? 'a+' : 'w+',
      encoding: 'utf8',
      mode: 0644
    });
  }

  if (options.errFile) {
    monitor.stderr = options.stderr || fs.createWriteStream(options.errFile, {
      flags: monitor.append ? 'a+' : 'w+',
      encoding: 'utf8',
      mode: 0644
    });
  }

  monitor.on('start', startLogs);
  monitor.on('restart', startLogs);
  monitor.on('exit', stopLogs);

  function stopLogs() {
    if (monitor.stdout) {
      //
      // Remark: 0.8.x doesnt have an unpipe method
      //
      monitor.child.stdout.unpipe &amp;&amp; monitor.child.stdout.unpipe(monitor.stdout);
      monitor.stdout.destroy();
      monitor.stdout = null;
    }
    //
    // Remark: 0.8.x doesnt have an unpipe method
    //
    if (monitor.stderr) {
      monitor.child.stderr.unpipe &amp;&amp; monitor.child.stderr.unpipe(monitor.stderr);
      monitor.stderr.destroy();
      monitor.stderr = null;
    }
  }

  function startLogs(child, childData) {
    if (monitor.child) {
      monitor.child.stdout.on('data', function onStdout(data) {
        monitor.emit('stdout', data);
      });

      monitor.child.stderr.on('data', function onStderr(data) {
        monitor.emit('stderr', data);
      });

      if (!monitor.silent) {
        process.stdout.setMaxListeners(0);
        process.stderr.setMaxListeners(0);
        monitor.child.stdout.pipe(process.stdout, { end: false });
        monitor.child.stderr.pipe(process.stderr, { end: false });
      }

      if (monitor.stdout) {
        monitor.child.stdout.pipe(monitor.stdout, { end: false });
      }

      if (monitor.stderr) {
        monitor.child.stderr.pipe(monitor.stderr, { end: false });
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.monitor" id="apidoc.module.forever-monitor.monitor">module forever-monitor.monitor</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.monitor.Monitor" id="apidoc.element.forever-monitor.monitor.Monitor">
        function <span class="apidocSignatureSpan">forever-monitor.monitor.</span>Monitor
        <span class="apidocSignatureSpan">(script, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Monitor = function (script, options) {
  //
  // Simple bootstrapper for attaching logger
  // and watch plugins by default. Other plugins
  // can be attached through `monitor.use(plugin, options)`.
  //
  function bootstrap(monitor) {
    plugins.logger.attach.call(monitor, options);
    if (options.watch) {
      plugins.watch.attach.call(monitor, options);
    }
  }

  var execPath = process.execPath,
      self     = this;

  //
  // Setup basic configuration options
  //
  options               = options || {};
  this.silent           = options.silent || false;
  this.killTree         = options.killTree !== false;
  this.uid              = options.uid || utile.randomString(4);
  this.id               = options.id || false;
  this.pidFile          = options.pidFile;
  this.max              = options.max;
  this.killTTL          = options.killTTL;
  this.killSignal       = options.killSignal || 'SIGKILL';
  this.childExists      = false;
  this.checkFile        = options.checkFile !== false;
  this.times            = 0;
  this.warn             = console.error;

  this.logFile          = options.logFile;
  this.outFile          = options.outFile;
  this.errFile          = options.errFile;
  this.append           = options.append;
  this.usePolling       = options.usePolling;
  this.pollingInterval  = options.pollingInterval;

  //
  // Define some safety checks for commands with spaces
  //
  this.parser = options.parser || Monitor.parseCommand;

  //
  // Setup restart timing. These options control how quickly forever restarts
  // a child process as well as when to kill a "spinning" process
  //
  this.minUptime     = typeof options.minUptime !== 'number' ? 0 : options.minUptime;
  this.spinSleepTime = options.spinSleepTime || null;

  //
  // Special case Windows separately to decouple any
  // future changes
  //
  if (process.platform === 'win32') {
    execPath = '"' + execPath + '"';
  }

  if (options.options) {
    console.warn('options.options is deprecated. Use options.args instead.');
  }

  //
  // Setup the command to spawn and the options to pass
  // to that command.
  //
  this.command   = options.command || execPath;
  this.args      = options.args || options.options || [];
  this.spawnWith = options.spawnWith || {};
  this.sourceDir = options.sourceDir;
  this.fork      = options.fork || false;
  this.cwd       = options.cwd || process.cwd();
  this.hideEnv   = options.hideEnv || [];
  this._env      = options.env || {};
  this._hideEnv  = {};

  //
  // Allow for custom stdio configuration of forked processes
  //
  this.stdio = options.stdio || null;

  //
  // Setup watch configuration options
  //
  this.watchIgnoreDotFiles = options.watchIgnoreDotFiles !== false;
  this.watchIgnorePatterns = options.watchIgnorePatterns || [];
  this.watchDirectory      = options.watchDirectory || this.sourceDir;

  //
  // Create a simple mapping of `this.hideEnv` to an easily indexable
  // object
  //
  this.hideEnv.forEach(function (key) {
    self._hideEnv[key] = true;
  });

  if (Array.isArray(script)) {
    this.command = script[0];
    this.args = script.slice(1);
  }
  else {
    this.args.unshift(script);
  }

  if (this.sourceDir) {
    this.args[0] = path.join(this.sourceDir, this.args[0]);
  }

  //
  // Bootstrap this instance now that options
  // have been set
  //
  broadway.App.call(this, { bootstrapper: { bootstrap: bootstrap } });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Starts a script with forever
//
exports.start = function (script, options) {
  if (!options.uid) {
    options.uid = options.uid || utile.randomString(4).replace(/^\-/, '_');
  }

  return new exports.<span class="apidocCodeKeywordSpan">Monitor</span>(script, options).start();
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.watch" id="apidoc.module.forever-monitor.watch">module forever-monitor.watch</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.watch.attach" id="apidoc.element.forever-monitor.watch.attach">
        function <span class="apidocSignatureSpan">forever-monitor.watch.</span>attach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attach = function () {
  var watchDirectory = this.watchDirectory,
      monitor = this;

  fs.readFile(path.join(this.watchDirectory, '.foreverignore'), 'utf8', function (err, data) {
    if (err) {
      return monitor.emit('watch:error', {
        message: 'Could not read .foreverignore file.',
        error: err.message
      });
    }

    Array.prototype.push.apply(monitor.watchIgnorePatterns, data.split('\n').filter(Boolean));
  });

  var opts = {
    usePolling: this.usePolling,
    interval: this.pollingInterval,
    ignoreInitial: true,
    ignored: function(fileName) {
      return !watchFilter.call(monitor, fileName);
    }
  };

  // Or, ignore: function(fileName) { return !watchFilter(fileName) }
  chokidar
    .watch(this.watchDirectory, opts)
    .on('all', function(f, stat) {
      monitor.emit('watch:restart', { file: f, stat: stat });
      monitor.restart();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>