<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/nodejitsu/forever-monitor#readme"

    >forever-monitor (v1.7.1)</a>
</h1>
<h4>Core forever process monitor</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor">module forever-monitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor">
            function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor
            <span class="apidocSignatureSpan">(script, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_">
            function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.checkProcess">
            function <span class="apidocSignatureSpan">forever-monitor.</span>checkProcess
            <span class="apidocSignatureSpan">(pid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.kill">
            function <span class="apidocSignatureSpan">forever-monitor.</span>kill
            <span class="apidocSignatureSpan">(pid, killTree, signal, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.start">
            function <span class="apidocSignatureSpan">forever-monitor.</span>start
            <span class="apidocSignatureSpan">(script, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.super_.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">forever-monitor.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor">module forever-monitor.Monitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.Monitor">
            function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor
            <span class="apidocSignatureSpan">(script, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.parseCommand">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>parseCommand
            <span class="apidocSignatureSpan">(command, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor.prototype">module forever-monitor.Monitor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype._getEnv">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>_getEnv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.kill">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>kill
            <span class="apidocSignatureSpan">(forceStop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.restart">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>restart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.send">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>send
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.start">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>start
            <span class="apidocSignatureSpan">(restart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.stop">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.toString">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.prototype.trySpawn">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>trySpawn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>inspect</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor.super_">module forever-monitor.Monitor.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>super_
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor.super_.prototype">module forever-monitor.Monitor.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.prototype.init">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>init
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.prototype.inspect">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.prototype.remove">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>remove
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.prototype.use">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>use
            <span class="apidocSignatureSpan">(plugin, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.forever-monitor.Monitor.super_.super_.prototype">module forever-monitor.Monitor.super_.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.addListener">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.emit">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listeners">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listenersAny">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>listenersAny
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.many">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>many
            <span class="apidocSignatureSpan">(event, ttl, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.off">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>off
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.offAny">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>offAny
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.on">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.onAny">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>onAny
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.once">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeListener">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>delimiter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>event</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor" id="apidoc.module.forever-monitor">module forever-monitor</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor" id="apidoc.element.forever-monitor.Monitor">
        function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor
        <span class="apidocSignatureSpan">(script, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Monitor = function (script, options) {
  //
  // Simple bootstrapper for attaching logger
  // and watch plugins by default. Other plugins
  // can be attached through `monitor.use(plugin, options)`.
  //
  function bootstrap(monitor) {
    plugins.logger.attach.call(monitor, options);
    if (options.watch) {
      plugins.watch.attach.call(monitor, options);
    }
  }

  var execPath = process.execPath,
      self     = this;

  //
  // Setup basic configuration options
  //
  options               = options || {};
  this.silent           = options.silent || false;
  this.killTree         = options.killTree !== false;
  this.uid              = options.uid || utile.randomString(4);
  this.id               = options.id || false;
  this.pidFile          = options.pidFile;
  this.max              = options.max;
  this.killTTL          = options.killTTL;
  this.killSignal       = options.killSignal || &#x27;SIGKILL&#x27;;
  this.childExists      = false;
  this.checkFile        = options.checkFile !== false;
  this.times            = 0;
  this.warn             = console.error;

  this.logFile          = options.logFile;
  this.outFile          = options.outFile;
  this.errFile          = options.errFile;
  this.append           = options.append;
  this.usePolling       = options.usePolling;
  this.pollingInterval  = options.pollingInterval;

  //
  // Define some safety checks for commands with spaces
  //
  this.parser = options.parser || Monitor.parseCommand;

  //
  // Setup restart timing. These options control how quickly forever restarts
  // a child process as well as when to kill a &#x22;spinning&#x22; process
  //
  this.minUptime     = typeof options.minUptime !== &#x27;number&#x27; ? 0 : options.minUptime;
  this.spinSleepTime = options.spinSleepTime || null;

  //
  // Special case Windows separately to decouple any
  // future changes
  //
  if (process.platform === &#x27;win32&#x27;) {
    execPath = &#x27;&#x22;&#x27; + execPath + &#x27;&#x22;&#x27;;
  }

  if (options.options) {
    console.warn(&#x27;options.options is deprecated. Use options.args instead.&#x27;);
  }

  //
  // Setup the command to spawn and the options to pass
  // to that command.
  //
  this.command   = options.command || execPath;
  this.args      = options.args || options.options || [];
  this.spawnWith = options.spawnWith || {};
  this.sourceDir = options.sourceDir;
  this.fork      = options.fork || false;
  this.cwd       = options.cwd || process.cwd();
  this.hideEnv   = options.hideEnv || [];
  this._env      = options.env || {};
  this._hideEnv  = {};

  //
  // Allow for custom stdio configuration of forked processes
  //
  this.stdio = options.stdio || null;

  //
  // Setup watch configuration options
  //
  this.watchIgnoreDotFiles = options.watchIgnoreDotFiles !== false;
  this.watchIgnorePatterns = options.watchIgnorePatterns || [];
  this.watchDirectory      = options.watchDirectory || this.sourceDir;

  //
  // Create a simple mapping of `this.hideEnv` to an easily indexable
  // object
  //
  this.hideEnv.forEach(function (key) {
    self._hideEnv[key] = true;
  });

  if (Array.isArray(script)) {
    this.command = script[0];
    this.args = script.slice(1);
  }
  else {
    this.args.unshift(script);
  }

  if (this.sourceDir) {
    this.args[0] = path.join(this.sourceDir, this.args[0]);
  }

  //
  // Bootstrap this instance now that options
  // have been set
  //
  broadway.App.call(this, { bootstrapper: { bootstrap: bootstrap } });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_" id="apidoc.element.forever-monitor.Monitor.super_">
        function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor.super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Monitor.super_ = function (options) {
  //
  // Setup options and `App` constants.
  //
  options        = options || {};
  this.root      = options.root;
  this.delimiter = options.delimiter || &#x27;::&#x27;;

  //
  // Inherit from `EventEmitter2`
  //
  events.EventEmitter2.call(this, {
    delimiter: this.delimiter,
    wildcard: true
  });

  //
  // Setup other relevant options such as the plugins
  // for this instance.
  //
  this.options      = options;
  this.env          = options.env || process.env[&#x27;NODE_ENV&#x27;] || &#x27;development&#x27;
  this.plugins      = options.plugins || {};
  this.initialized  = false;
  this.bootstrapper = options.bootstrapper || bootstrapper;
  this.initializers = {};
  this.initlist     = [];

  //
  // Bootstrap this instance
  //
  this.bootstrapper.bootstrap(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.checkProcess" id="apidoc.element.forever-monitor.checkProcess">
        function <span class="apidocSignatureSpan">forever-monitor.</span>checkProcess
        <span class="apidocSignatureSpan">(pid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkProcess = function (pid) {
  if (!pid) {
    return false;
  }

  try {
    //
    // Trying to kill non-existent process here raises a ESRCH - no such
    // process exception. Also, signal 0 doesn&#x27;t do no harm to a process - it
    // only checks if sending a signal to a given process is possible.
    //
    process.kill(pid, 0);
    return true;
  }
  catch (err) {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.kill" id="apidoc.element.forever-monitor.kill">
        function <span class="apidocSignatureSpan">forever-monitor.</span>kill
        <span class="apidocSignatureSpan">(pid, killTree, signal, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (pid, killTree, signal, callback) {
  signal   = signal   || &#x27;SIGKILL&#x27;;
  callback = callback || function () {};

  if (killTree &#x26;&#x26; process.platform !== &#x27;win32&#x27;) {
    psTree(pid, function (err, children) {
      [pid].concat(
        children.map(function (p) {
          return p.PID;
        })
      ).forEach(function (tpid) {
        try { process.kill(tpid, signal) }
        catch (ex) { }
      });

      callback();
    });
  }
  else {
    try { process.kill(pid, signal) }
    catch (ex) { }
    callback();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.start" id="apidoc.element.forever-monitor.start">
        function <span class="apidocSignatureSpan">forever-monitor.</span>start
        <span class="apidocSignatureSpan">(script, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (script, options) {
  if (!options.uid) {
    options.uid = options.uid || utile.randomString(4).replace(/^\-/, &#x27;_&#x27;);
  }

  return new exports.Monitor(script, options).start();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args: []
  });

  child.on(&#x27;exit&#x27;, function () {
    console.log(&#x27;your-filename.js has exited after 3 restarts&#x27;);
  });

  child.<span class="apidocCodeKeywordSpan">start</span>();
```

### Spawning a non-node process
You can spawn non-node processes too. Either set the `command` key in the
`options` hash or pass in an `Array` in place of the `file` argument like this:

``` js
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor" id="apidoc.module.forever-monitor.Monitor">module forever-monitor.Monitor</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.Monitor" id="apidoc.element.forever-monitor.Monitor.Monitor">
        function <span class="apidocSignatureSpan">forever-monitor.</span>Monitor
        <span class="apidocSignatureSpan">(script, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Monitor = function (script, options) {
  //
  // Simple bootstrapper for attaching logger
  // and watch plugins by default. Other plugins
  // can be attached through `monitor.use(plugin, options)`.
  //
  function bootstrap(monitor) {
    plugins.logger.attach.call(monitor, options);
    if (options.watch) {
      plugins.watch.attach.call(monitor, options);
    }
  }

  var execPath = process.execPath,
      self     = this;

  //
  // Setup basic configuration options
  //
  options               = options || {};
  this.silent           = options.silent || false;
  this.killTree         = options.killTree !== false;
  this.uid              = options.uid || utile.randomString(4);
  this.id               = options.id || false;
  this.pidFile          = options.pidFile;
  this.max              = options.max;
  this.killTTL          = options.killTTL;
  this.killSignal       = options.killSignal || &#x27;SIGKILL&#x27;;
  this.childExists      = false;
  this.checkFile        = options.checkFile !== false;
  this.times            = 0;
  this.warn             = console.error;

  this.logFile          = options.logFile;
  this.outFile          = options.outFile;
  this.errFile          = options.errFile;
  this.append           = options.append;
  this.usePolling       = options.usePolling;
  this.pollingInterval  = options.pollingInterval;

  //
  // Define some safety checks for commands with spaces
  //
  this.parser = options.parser || Monitor.parseCommand;

  //
  // Setup restart timing. These options control how quickly forever restarts
  // a child process as well as when to kill a &#x22;spinning&#x22; process
  //
  this.minUptime     = typeof options.minUptime !== &#x27;number&#x27; ? 0 : options.minUptime;
  this.spinSleepTime = options.spinSleepTime || null;

  //
  // Special case Windows separately to decouple any
  // future changes
  //
  if (process.platform === &#x27;win32&#x27;) {
    execPath = &#x27;&#x22;&#x27; + execPath + &#x27;&#x22;&#x27;;
  }

  if (options.options) {
    console.warn(&#x27;options.options is deprecated. Use options.args instead.&#x27;);
  }

  //
  // Setup the command to spawn and the options to pass
  // to that command.
  //
  this.command   = options.command || execPath;
  this.args      = options.args || options.options || [];
  this.spawnWith = options.spawnWith || {};
  this.sourceDir = options.sourceDir;
  this.fork      = options.fork || false;
  this.cwd       = options.cwd || process.cwd();
  this.hideEnv   = options.hideEnv || [];
  this._env      = options.env || {};
  this._hideEnv  = {};

  //
  // Allow for custom stdio configuration of forked processes
  //
  this.stdio = options.stdio || null;

  //
  // Setup watch configuration options
  //
  this.watchIgnoreDotFiles = options.watchIgnoreDotFiles !== false;
  this.watchIgnorePatterns = options.watchIgnorePatterns || [];
  this.watchDirectory      = options.watchDirectory || this.sourceDir;

  //
  // Create a simple mapping of `this.hideEnv` to an easily indexable
  // object
  //
  this.hideEnv.forEach(function (key) {
    self._hideEnv[key] = true;
  });

  if (Array.isArray(script)) {
    this.command = script[0];
    this.args = script.slice(1);
  }
  else {
    this.args.unshift(script);
  }

  if (this.sourceDir) {
    this.args[0] = path.join(this.sourceDir, this.args[0]);
  }

  //
  // Bootstrap this instance now that options
  // have been set
  //
  broadway.App.call(this, { bootstrapper: { bootstrap: bootstrap } });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.parseCommand" id="apidoc.element.forever-monitor.Monitor.parseCommand">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>parseCommand
        <span class="apidocSignatureSpan">(command, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCommand = function (command, args) {
  var match = command.match(
    process.platform === &#x27;win32&#x27; ? safetyChecks.windows : safetyChecks.linux
  );

  //
  // No match means it&#x27;s a bad command. This is configurable
  // by passing a custom `parser` function into the `Monitor`
  // constructor function.
  //
  if (!match) { return false; }

  if (process.platform == &#x27;win32&#x27;) {
    command = match[1] || match[2];
    if (match[3]) {
      args = match[3].split(&#x27; &#x27;).concat(args);
    }
  } else {
    command = match[1];
    if (match[2]) {
      args = match[2].split(&#x27; &#x27;).concat(this.args);
    }
  }

  return {
    command: command,
    args:    args
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_" id="apidoc.element.forever-monitor.Monitor.super_">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (options) {
  //
  // Setup options and `App` constants.
  //
  options        = options || {};
  this.root      = options.root;
  this.delimiter = options.delimiter || &#x27;::&#x27;;

  //
  // Inherit from `EventEmitter2`
  //
  events.EventEmitter2.call(this, {
    delimiter: this.delimiter,
    wildcard: true
  });

  //
  // Setup other relevant options such as the plugins
  // for this instance.
  //
  this.options      = options;
  this.env          = options.env || process.env[&#x27;NODE_ENV&#x27;] || &#x27;development&#x27;
  this.plugins      = options.plugins || {};
  this.initialized  = false;
  this.bootstrapper = options.bootstrapper || bootstrapper;
  this.initializers = {};
  this.initlist     = [];

  //
  // Bootstrap this instance
  //
  this.bootstrapper.bootstrap(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor.prototype" id="apidoc.module.forever-monitor.Monitor.prototype">module forever-monitor.Monitor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype._getEnv" id="apidoc.element.forever-monitor.Monitor.prototype._getEnv">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>_getEnv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getEnv = function () {
  var self = this,
      merged = {};

  function addKey(key, source) {
    merged[key] = source[key];
  }

  //
  // Mixin the key:value pairs from `process.env` and the custom
  // environment variables in `this._env`.
  //
  Object.keys(process.env).forEach(function (key) {
    if (!self._hideEnv[key]) {
      addKey(key, process.env);
    }
  });

  Object.keys(this._env).forEach(function (key) {
    addKey(key, self._env);
  });

  return merged;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.kill" id="apidoc.element.forever-monitor.Monitor.prototype.kill">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>kill
        <span class="apidocSignatureSpan">(forceStop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (forceStop) {
  var child = this.child,
      self = this,
      timer;

  if (!child || (!this.running &#x26;&#x26; !this.forceRestart)) {
    process.nextTick(function () {
      self.emit(&#x27;error&#x27;, new Error(&#x27;Cannot stop process that is not running.&#x27;));
    });
  }
  else {
    //
    // Set an instance variable here to indicate this
    // stoppage is forced so that when `child.on(&#x27;exit&#x27;, ..)`
    // fires in `Monitor.prototype.start` we can short circuit
    // and prevent auto-restart
    //
    if (forceStop) {
      this.forceStop = true;
      //
      // If we have a time before we truly kill forcefully, set up a timer
      //
      if (this.killTTL) {
        timer = setTimeout(function () {
          common.kill(self.child.pid, self.killTree, self.killSignal || &#x27;SIGKILL&#x27;);
        }, this.killTTL);

        child.once(&#x27;exit&#x27;, function () {
          clearTimeout(timer);
        });
      }
    }

    child.once(&#x27;exit&#x27;, function () {
      self.emit(&#x27;stop&#x27;, self.childData);
      if (self.forceRestart &#x26;&#x26; !self.running) {
        self.start(true);
      }
    });

    common.kill(this.child.pid, this.killTree, this.killSignal);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.restart" id="apidoc.element.forever-monitor.Monitor.prototype.restart">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>restart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restart = function () {
  this.times = this.times || 0;
  this.forceRestart = true;

  return !this.running
    ? this.start(true)
    : this.kill(false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.send" id="apidoc.element.forever-monitor.Monitor.prototype.send">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>send
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (msg) {
  var child = this.child,
      self = this;

  if (!child || !this.running) {
    process.nextTick(function () {
      self.emit(&#x27;error&#x27;, new Error(&#x27;Cannot send to process that is not running.&#x27;));
    });
  }

  if (child.send) { child.send(msg) }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.start" id="apidoc.element.forever-monitor.Monitor.prototype.start">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>start
        <span class="apidocSignatureSpan">(restart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (restart) {
  var self = this,
      child;

  if (this.running &#x26;&#x26; !restart) {
    process.nextTick(function () {
      self.emit(&#x27;error&#x27;, new Error(&#x27;Cannot start process that is already running.&#x27;));
    });
    return this;
  }

  child = this.trySpawn();
  if (!child) {
    process.nextTick(function () {
      self.emit(&#x27;error&#x27;, new Error(&#x27;Target script does not exist: &#x27; + self.args[0]));
    });
    return this;
  }

  this.ctime = Date.now();
  this.child = child;
  this.running = true;
  this.isMaster = cluster.isMaster;

  process.nextTick(function () {
    self.emit(restart ? &#x27;restart&#x27; : &#x27;start&#x27;, self, self.data);
  });

  function onMessage(msg) {
    self.emit(&#x27;message&#x27;, msg);
  }

  // Re-emit messages from the child process
  this.child.on(&#x27;message&#x27;, onMessage);

  child.on(&#x27;exit&#x27;, function (code, signal) {
    var spinning = Date.now() - self.ctime &#x3c; self.minUptime;
    child.removeListener(&#x27;message&#x27;, onMessage);
    self.emit(&#x27;exit:code&#x27;, code, signal);

    function letChildDie() {
      self.running = false;
      self.forceStop = false;
      self.emit(&#x27;exit&#x27;, self, spinning);
    }

    function restartChild() {
      self.forceRestart = false;
      process.nextTick(function () {
        self.start(true);
      });
    }

    self.times++;

    if (self.forceStop || (self.times &#x3e;= self.max &#x26;&#x26; !self.forceRestart)
      || (spinning &#x26;&#x26; typeof self.spinSleepTime !== &#x27;number&#x27;) &#x26;&#x26; !self.forceRestart) {
      letChildDie();
    }
    else if (spinning) {
      setTimeout(restartChild, self.spinSleepTime);
    }
    else {
      restartChild();
    }
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args: []
  });

  child.on(&#x27;exit&#x27;, function () {
    console.log(&#x27;your-filename.js has exited after 3 restarts&#x27;);
  });

  child.<span class="apidocCodeKeywordSpan">start</span>();
```

### Spawning a non-node process
You can spawn non-node processes too. Either set the `command` key in the
`options` hash or pass in an `Array` in place of the `file` argument like this:

``` js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.stop" id="apidoc.element.forever-monitor.Monitor.prototype.stop">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function () {
  return this.kill(true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.toString" id="apidoc.element.forever-monitor.Monitor.prototype.toString">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return JSON.stringify(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.prototype.trySpawn" id="apidoc.element.forever-monitor.Monitor.prototype.trySpawn">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.prototype.</span>trySpawn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trySpawn = function () {
  var run = this.parser(this.command, this.args.slice()),
      stats;

  if (/[^\w]node$/.test(this.command) &#x26;&#x26; this.checkFile &#x26;&#x26; !this.childExists) {
    try {
      stats = fs.statSync(this.args[0]);
      this.childExists = true;
    }
    catch (ex) {
      return false;
    }
  }

  this.spawnWith.cwd = this.spawnWith.cwd || this.cwd;
  this.spawnWith.env = this._getEnv();

  if (process.platform === &#x27;win32&#x27;) {
    this.spawnWith.detached = true;
  }

  if (this.stdio) {
    this.spawnWith.stdio = this.stdio;
  }

  if (this.fork) {
    if (!this.stdio) {
      this.spawnWith.stdio = [ &#x27;pipe&#x27;, &#x27;pipe&#x27;, &#x27;pipe&#x27;, &#x27;ipc&#x27; ];
    }
    return spawn(run.command, run.args, this.spawnWith);
  }

  return spawn(run.command, run.args, this.spawnWith);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor.super_" id="apidoc.module.forever-monitor.Monitor.super_">module forever-monitor.Monitor.super_</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_" id="apidoc.element.forever-monitor.Monitor.super_.super_">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.</span>super_
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(conf) {
  this._events = {};
  this.newListener = false;
  configure.call(this, conf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor.super_.prototype" id="apidoc.module.forever-monitor.Monitor.super_.prototype">module forever-monitor.Monitor.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.prototype.init" id="apidoc.element.forever-monitor.Monitor.super_.prototype.init">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>init
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (options, callback) {
  if (!callback &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }

  if (this.initialized) {
    return callback();
  }

  var self = this;
  options = options   || {};
  callback = callback || function () {};
  this.env = options.env || this.env;
  this.options = common.mixin({}, this.options, options);

  function onComplete() {
    self.initialized = true;
    self.emit(&#x27;init&#x27;);
    callback();
  }

  function ensureFeatures (err) {
    return err
      ? onError(err)
      : features.ensure(this, onComplete);
  }

  function initPlugin(plugin, next) {
    if (typeof self.initializers[plugin] === &#x27;function&#x27;) {
      return self.initializers[plugin].call(self, function (err) {
        if (err) {
          return next(err);
        }

        self.emit([&#x27;plugin&#x27;, plugin, &#x27;init&#x27;]);
        self.initializers[plugin] = true;
        next();
      });
    }

    next();
  }

  function initPlugins() {
    async.forEach(self.initlist, initPlugin, ensureFeatures);
  }

  //
  // Emit and respond with any errors that may short
  // circuit the process.
  //
  function onError(err) {
    self.emit([&#x27;error&#x27;, &#x27;init&#x27;], err);
    callback(err);
  }

  //
  // Run the bootstrapper, initialize plugins, and
  // ensure features for this instance.
  //
  this.bootstrapper.init(this, initPlugins);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.prototype.inspect" id="apidoc.element.forever-monitor.Monitor.super_.prototype.inspect">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.prototype.remove" id="apidoc.element.forever-monitor.Monitor.super_.prototype.remove">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>remove
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (name) {
  // if this is a plugin object set the name to the plugins name
  if (name.name) {
    name = name.name;
  }

  if (this.plugins[name] &#x26;&#x26; this.plugins[name].detach) {
    this.plugins[name].detach.call(this);
  }

  delete this.plugins[name];
  delete this.options[name];
  delete this.initializers[name];

  var init = this.initlist.indexOf(name);

  if (init !== -1) {
    this.initlist.splice(1, init);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.prototype.use" id="apidoc.element.forever-monitor.Monitor.super_.prototype.use">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.prototype.</span>use
        <span class="apidocSignatureSpan">(plugin, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (plugin, options, callback) {
  options = options || {};

  if (typeof plugin === &#x27;undefined&#x27;) {
    console.log(&#x27;Cannot load invalid plugin!&#x27;);
    return callback &#x26;&#x26; callback(new Error(&#x27;Invalid plugin&#x27;));
  }

  var name = plugin.name,
      self = this;

  // If the plugin doesn&#x27;t have a name, use itself as an identifier for the plugins hash.
  if (!name) {
    name = common.uuid();
  }

  if (this.plugins[name]) {
    return callback &#x26;&#x26; callback();
  }

  //
  // Setup state on this instance for the specified plugin
  //
  this.plugins[name] = plugin;
  this.options[name] = common.mixin({}, options, this.options[name] || {});

  //
  // Attach the specified plugin to this instance, extending
  // the `App` with new functionality.
  //
  if (this.plugins[name].attach &#x26;&#x26; options.attach !== false) {
    this.plugins[name].attach.call(this, options);
  }

  //
  // Setup the initializer only if `options.init` is
  // not false. This allows for some plugins to be lazy-loaded
  //
  if (options.init === false) {
    return callback &#x26;&#x26; callback();
  }

  if (!this.initialized) {
    this.initializers[name] = plugin.init || true;
    this.initlist.push(name);
    return callback &#x26;&#x26; callback();
  }
  else if (plugin.init) {
    plugin.init.call(this, function (err) {
      var args = err
        ? [[&#x27;plugin&#x27;, name, &#x27;error&#x27;], err]
        : [[&#x27;plugin&#x27;, name, &#x27;init&#x27;]];

      self.emit.apply(self, args);
      return callback &#x26;&#x26; (err ? callback(err) : callback());
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.forever-monitor.Monitor.super_.super_.prototype" id="apidoc.module.forever-monitor.Monitor.super_.super_.prototype">module forever-monitor.Monitor.super_.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.addListener" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.addListener">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (type, listener) {

  if (typeof type === &#x27;function&#x27;) {
    this.onAny(type);
    return this;
  }

  if (typeof listener !== &#x27;function&#x27;) {
    throw new Error(&#x27;on only accepts instances of Function&#x27;);
  }
  this._events || init.call(this);

  // To avoid recursion in the case that type == &#x22;newListeners&#x22;! Before
  // adding it to the listeners, first emit &#x22;newListeners&#x22;.
  this.emit(&#x27;newListener&#x27;, type, listener);

  if(this.wildcard) {
    growListenerTree.call(this, type, listener);
    return this;
  }

  if (!this._events[type]) {
    // Optimize the case of one listener. Don&#x27;t need the extra array object.
    this._events[type] = listener;
  }
  else if(typeof this._events[type] === &#x27;function&#x27;) {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }
  else if (isArray(this._events[type])) {
    // If we&#x27;ve already got an array, just append.
    this._events[type].push(listener);

    // Check for listener leak
    if (!this._events[type].warned) {

      var m = defaultMaxListeners;

      if (typeof this._events.maxListeners !== &#x27;undefined&#x27;) {
        m = this._events.maxListeners;
      }

      if (m &#x3e; 0 &#x26;&#x26; this._events[type].length &#x3e; m) {

        this._events[type].warned = true;
        console.error(&#x27;(node) warning: possible EventEmitter memory &#x27; +
                      &#x27;leak detected. %d listeners added. &#x27; +
                      &#x27;Use emitter.setMaxListeners() to increase limit.&#x27;,
                      this._events[type].length);
        console.trace();
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.emit" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.emit">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () {

  this._events || init.call(this);

  var type = arguments[0];

  if (type === &#x27;newListener&#x27; &#x26;&#x26; !this.newListener) {
    if (!this._events.newListener) { return false; }
  }

  // Loop through the *_all* functions and invoke them.
  if (this._all) {
    var l = arguments.length;
    var args = new Array(l - 1);
    for (var i = 1; i &#x3c; l; i++) args[i - 1] = arguments[i];
    for (i = 0, l = this._all.length; i &#x3c; l; i++) {
      this.event = type;
      this._all[i].apply(this, args);
    }
  }

  // If there is no &#x27;error&#x27; event listener then throw.
  if (type === &#x27;error&#x27;) {

    if (!this._all &#x26;&#x26;
      !this._events.error &#x26;&#x26;
      !(this.wildcard &#x26;&#x26; this.listenerTree.error)) {

      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled &#x27;error&#x27; event
      } else {
        throw new Error(&#x22;Uncaught, unspecified &#x27;error&#x27; event.&#x22;);
      }
      return false;
    }
  }

  var handler;

  if(this.wildcard) {
    handler = [];
    var ns = typeof type === &#x27;string&#x27; ? type.split(this.delimiter) : type.slice();
    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
  }
  else {
    handler = this._events[type];
  }

  if (typeof handler === &#x27;function&#x27;) {
    this.event = type;
    if (arguments.length === 1) {
      handler.call(this);
    }
    else if (arguments.length &#x3e; 1)
      switch (arguments.length) {
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          var l = arguments.length;
          var args = new Array(l - 1);
          for (var i = 1; i &#x3c; l; i++) args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    return true;
  }
  else if (handler) {
    var l = arguments.length;
    var args = new Array(l - 1);
    for (var i = 1; i &#x3c; l; i++) args[i - 1] = arguments[i];

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i &#x3c; l; i++) {
      this.event = type;
      listeners[i].apply(this, args);
    }
    return (listeners.length &#x3e; 0) || !!this._all;
  }
  else {
    return !!this._all;
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listeners" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listeners">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function (type) {
  if(this.wildcard) {
    var handlers = [];
    var ns = typeof type === &#x27;string&#x27; ? type.split(this.delimiter) : type.slice();
    searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
    return handlers;
  }

  this._events || init.call(this);

  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listenersAny" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.listenersAny">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>listenersAny
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenersAny = function () {

  if(this._all) {
    return this._all;
  }
  else {
    return [];
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.many" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.many">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>many
        <span class="apidocSignatureSpan">(event, ttl, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">many = function (event, ttl, fn) {
  var self = this;

  if (typeof fn !== &#x27;function&#x27;) {
    throw new Error(&#x27;many only accepts instances of Function&#x27;);
  }

  function listener() {
    if (--ttl === 0) {
      self.off(event, listener);
    }
    fn.apply(this, arguments);
  }

  listener._origin = fn;

  this.on(event, listener);

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.off" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.off">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>off
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (type, listener) {
  if (typeof listener !== &#x27;function&#x27;) {
    throw new Error(&#x27;removeListener only takes instances of Function&#x27;);
  }

  var handlers,leafs=[];

  if(this.wildcard) {
    var ns = typeof type === &#x27;string&#x27; ? type.split(this.delimiter) : type.slice();
    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
  }
  else {
    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events[type]) return this;
    handlers = this._events[type];
    leafs.push({_listeners:handlers});
  }

  for (var iLeaf=0; iLeaf&#x3c;leafs.length; iLeaf++) {
    var leaf = leafs[iLeaf];
    handlers = leaf._listeners;
    if (isArray(handlers)) {

      var position = -1;

      for (var i = 0, length = handlers.length; i &#x3c; length; i++) {
        if (handlers[i] === listener ||
          (handlers[i].listener &#x26;&#x26; handlers[i].listener === listener) ||
          (handlers[i]._origin &#x26;&#x26; handlers[i]._origin === listener)) {
          position = i;
          break;
        }
      }

      if (position &#x3c; 0) {
        continue;
      }

      if(this.wildcard) {
        leaf._listeners.splice(position, 1);
      }
      else {
        this._events[type].splice(position, 1);
      }

      if (handlers.length === 0) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
      return this;
    }
    else if (handlers === listener ||
      (handlers.listener &#x26;&#x26; handlers.listener === listener) ||
      (handlers._origin &#x26;&#x26; handlers._origin === listener)) {
      if(this.wildcard) {
        delete leaf._listeners;
      }
      else {
        delete this._events[type];
      }
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.offAny" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.offAny">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>offAny
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offAny = function (fn) {
  var i = 0, l = 0, fns;
  if (fn &#x26;&#x26; this._all &#x26;&#x26; this._all.length &#x3e; 0) {
    fns = this._all;
    for(i = 0, l = fns.length; i &#x3c; l; i++) {
      if(fn === fns[i]) {
        fns.splice(i, 1);
        return this;
      }
    }
  } else {
    this._all = [];
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.on" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.on">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (type, listener) {

  if (typeof type === &#x27;function&#x27;) {
    this.onAny(type);
    return this;
  }

  if (typeof listener !== &#x27;function&#x27;) {
    throw new Error(&#x27;on only accepts instances of Function&#x27;);
  }
  this._events || init.call(this);

  // To avoid recursion in the case that type == &#x22;newListeners&#x22;! Before
  // adding it to the listeners, first emit &#x22;newListeners&#x22;.
  this.emit(&#x27;newListener&#x27;, type, listener);

  if(this.wildcard) {
    growListenerTree.call(this, type, listener);
    return this;
  }

  if (!this._events[type]) {
    // Optimize the case of one listener. Don&#x27;t need the extra array object.
    this._events[type] = listener;
  }
  else if(typeof this._events[type] === &#x27;function&#x27;) {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }
  else if (isArray(this._events[type])) {
    // If we&#x27;ve already got an array, just append.
    this._events[type].push(listener);

    // Check for listener leak
    if (!this._events[type].warned) {

      var m = defaultMaxListeners;

      if (typeof this._events.maxListeners !== &#x27;undefined&#x27;) {
        m = this._events.maxListeners;
      }

      if (m &#x3e; 0 &#x26;&#x26; this._events[type].length &#x3e; m) {

        this._events[type].warned = true;
        console.error(&#x27;(node) warning: possible EventEmitter memory &#x27; +
                      &#x27;leak detected. %d listeners added. &#x27; +
                      &#x27;Use emitter.setMaxListeners() to increase limit.&#x27;,
                      this._events[type].length);
        console.trace();
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var child = new (forever.Monitor)(&#x27;your-filename.js&#x27;, {
    max: 3,
    silent: true,
    args: []
  });

  child.<span class="apidocCodeKeywordSpan">on</span>(&#x27;exit&#x27;, function () {
    console.log(&#x27;your-filename.js has exited after 3 restarts&#x27;);
  });

  child.start();
```

### Spawning a non-node process
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.onAny" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.onAny">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>onAny
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onAny = function (fn) {

  if (typeof fn !== &#x27;function&#x27;) {
    throw new Error(&#x27;onAny only accepts instances of Function&#x27;);
  }

  if(!this._all) {
    this._all = [];
  }

  // Add the function to the event listener collection.
  this._all.push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.once" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.once">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (event, fn) {
  this.many(event, 1, fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeAllListeners" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function (type) {
  if (arguments.length === 0) {
    !this._events || init.call(this);
    return this;
  }

  if(this.wildcard) {
    var ns = typeof type === &#x27;string&#x27; ? type.split(this.delimiter) : type.slice();
    var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

    for (var iLeaf=0; iLeaf&#x3c;leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      leaf._listeners = null;
    }
  }
  else {
    if (!this._events[type]) return this;
    this._events[type] = null;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeListener" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.removeListener">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (type, listener) {
  if (typeof listener !== &#x27;function&#x27;) {
    throw new Error(&#x27;removeListener only takes instances of Function&#x27;);
  }

  var handlers,leafs=[];

  if(this.wildcard) {
    var ns = typeof type === &#x27;string&#x27; ? type.split(this.delimiter) : type.slice();
    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
  }
  else {
    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events[type]) return this;
    handlers = this._events[type];
    leafs.push({_listeners:handlers});
  }

  for (var iLeaf=0; iLeaf&#x3c;leafs.length; iLeaf++) {
    var leaf = leafs[iLeaf];
    handlers = leaf._listeners;
    if (isArray(handlers)) {

      var position = -1;

      for (var i = 0, length = handlers.length; i &#x3c; length; i++) {
        if (handlers[i] === listener ||
          (handlers[i].listener &#x26;&#x26; handlers[i].listener === listener) ||
          (handlers[i]._origin &#x26;&#x26; handlers[i]._origin === listener)) {
          position = i;
          break;
        }
      }

      if (position &#x3c; 0) {
        continue;
      }

      if(this.wildcard) {
        leaf._listeners.splice(position, 1);
      }
      else {
        this._events[type].splice(position, 1);
      }

      if (handlers.length === 0) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
      return this;
    }
    else if (handlers === listener ||
      (handlers.listener &#x26;&#x26; handlers.listener === listener) ||
      (handlers._origin &#x26;&#x26; handlers._origin === listener)) {
      if(this.wildcard) {
        delete leaf._listeners;
      }
      else {
        delete this._events[type];
      }
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.forever-monitor.Monitor.super_.super_.prototype.setMaxListeners" id="apidoc.element.forever-monitor.Monitor.super_.super_.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">forever-monitor.Monitor.super_.super_.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function (n) {
  this._events || init.call(this);
  this._events.maxListeners = n;
  if (!this._conf) this._conf = {};
  this._conf.maxListeners = n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
